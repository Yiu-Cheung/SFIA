# Generated by AI on 2024-12-19
# Reviewed by: AI Assistant
# Ticket: SFIA-003

# Layer: infrastructure
# Responsibility: Convert XLSX files to structured JSON documents optimized for AI reading
# Public API: StructuredXLSXConverter.convert_file()

from typing import List, Dict, Any, Optional
from pathlib import Path
import os
import json
import pandas as pd

from ...domain.models.document import Document as DomainDocument


class StructuredXLSXConverter:
    """Converts XLSX files to structured JSON documents optimized for AI reading."""
    
    def __init__(
        self,
        save_debug_files: bool = True,
        debug_folder: str = "doc/.converted",
        output_format: str = "json"
    ) -> None:
        """Initialize the structured XLSX converter.
        
        Args:
            save_debug_files: Whether to save converted documents to debug folder.
            debug_folder: Folder to save debug files.
            output_format: Output format ('json' or 'text').
        """
        self._save_debug_files = save_debug_files
        self._debug_folder = debug_folder
        self._output_format = output_format
        
        # Create debug folder if needed
        if self._save_debug_files:
            os.makedirs(self._debug_folder, exist_ok=True)
    
    def convert_file(self, file_path: str) -> List[DomainDocument]:
        """Convert an XLSX file to structured domain documents.
        
        Args:
            file_path: Path to the XLSX file.
            
        Returns:
            List of domain documents converted from the XLSX file.
        """
        if not Path(file_path).exists():
            raise FileNotFoundError(f"XLSX file not found: {file_path}")
        
        documents = []
        
        try:
            # Read all sheets from the Excel file
            excel_file = pd.ExcelFile(file_path)
            
            for sheet_name in excel_file.sheet_names:
                # Skip sheets that are not relevant for SFIA skills
                if sheet_name.lower() in ['read me notes', 'terms of use']:
                    continue
                
                df = pd.read_excel(
                    file_path, 
                    sheet_name=sheet_name,
                    engine='openpyxl' if file_path.endswith('.xlsx') else None
                )
                
                # For Skills sheet, create individual documents for each skill
                if sheet_name.lower() == 'skills':
                    skill_docs = self._process_skills_sheet(df, file_path, sheet_name)
                    documents.extend(skill_docs)
                else:
                    # For other sheets, create a single structured document
                    sheet_doc = self._process_general_sheet(df, file_path, sheet_name)
                    if sheet_doc:
                        documents.append(sheet_doc)
                        
        except Exception as e:
            print(f"Failed to convert {file_path}: {e}")
        
        return documents
    
    def _process_skills_sheet(self, df: pd.DataFrame, file_path: str, sheet_name: str) -> List[DomainDocument]:
        """Process the Skills sheet to create individual structured documents for each skill."""
        documents = []
        
        # Look for the Skill column
        skill_column = None
        for col in df.columns:
            if 'skill' in str(col).lower():
                skill_column = col
                break
        
        if skill_column is None:
            print("No skill column found in Skills sheet")
            return documents
        
        # Process each skill row
        for index, row in df.iterrows():
            skill_name = str(row[skill_column]).strip()
            if skill_name and skill_name.lower() != 'nan' and skill_name != 'Skill':
                # Create structured content for this skill
                skill_data = self._extract_skill_data(row, df.columns, skill_column)
                
                # Create document content based on output format
                if self._output_format == "json":
                    content = self._create_json_content(skill_data)
                else:
                    content = self._create_text_content(skill_data)
                
                # Create domain document
                doc = DomainDocument(
                    content=content,
                    metadata={
                        "source": file_path,
                        "type": "xlsx",
                        "format": self._output_format,
                        "sheet": sheet_name,
                        "skill": skill_name,
                        "row": index,
                        "skill_code": skill_data.get("code", ""),
                        "category": skill_data.get("category", ""),
                        "subcategory": skill_data.get("subcategory", "")
                    }
                )
                
                documents.append(doc)
                
                # Save debug file if enabled
                if self._save_debug_files:
                    self._save_debug_file(doc, file_path, f"skill_{index}")
        
        return documents
    
    def _extract_skill_data(self, row: pd.Series, columns: pd.Index, skill_column: str) -> Dict[str, Any]:
        """Extract structured data for a skill from a row."""
        skill_data = {
            "skill_name": str(row[skill_column]).strip(),
            "code": "",
            "url": "",
            "category": "",
            "subcategory": "",
            "overall_description": "",
            "guidance_notes": "",
            "level_descriptions": {}
        }
        
        # Extract basic information
        for col in columns:
            col_str = str(col).lower()
            value = str(row[col]).strip()
            
            if value and value.lower() != 'nan':
                if 'code' in col_str:
                    skill_data["code"] = value
                elif 'url' in col_str:
                    skill_data["url"] = value
                elif 'category' in col_str and 'subcategory' not in col_str:
                    skill_data["category"] = value
                elif 'subcategory' in col_str:
                    skill_data["subcategory"] = value
                elif 'overall description' in col_str:
                    skill_data["overall_description"] = value
                elif 'guidance notes' in col_str:
                    skill_data["guidance_notes"] = value
                elif 'level' in col_str and 'description' in col_str:
                    # Extract level number from column name
                    level_match = None
                    for i in range(1, 8):  # Levels 1-7
                        if f"level {i}" in col_str:
                            level_match = i
                            break
                    
                    if level_match:
                        skill_data["level_descriptions"][f"level_{level_match}"] = value
        
        return skill_data
    
    def _create_json_content(self, skill_data: Dict[str, Any]) -> str:
        """Create JSON content for a skill."""
        return json.dumps(skill_data, indent=2, ensure_ascii=False)
    
    def _create_text_content(self, skill_data: Dict[str, Any]) -> str:
        """Create structured text content for a skill."""
        lines = []
        lines.append(f"SKILL: {skill_data['skill_name']}")
        lines.append(f"CODE: {skill_data['code']}")
        lines.append(f"CATEGORY: {skill_data['category']}")
        lines.append(f"SUBCATEGORY: {skill_data['subcategory']}")
        lines.append(f"URL: {skill_data['url']}")
        lines.append("")
        
        if skill_data['overall_description']:
            lines.append("OVERALL DESCRIPTION:")
            lines.append(skill_data['overall_description'])
            lines.append("")
        
        if skill_data['guidance_notes']:
            lines.append("GUIDANCE NOTES:")
            lines.append(skill_data['guidance_notes'])
            lines.append("")
        
        if skill_data['level_descriptions']:
            lines.append("LEVEL DESCRIPTIONS:")
            for level, description in skill_data['level_descriptions'].items():
                lines.append(f"{level.upper()}: {description}")
                lines.append("")
        
        return "\n".join(lines)
    
    def _process_general_sheet(self, df: pd.DataFrame, file_path: str, sheet_name: str) -> Optional[DomainDocument]:
        """Process a general sheet (non-skills) to create a structured document."""
        sheet_data = {
            "sheet_name": sheet_name,
            "rows": len(df),
            "columns": len(df.columns),
            "column_names": df.columns.tolist(),
            "data": []
        }
        
        # Convert DataFrame to list of dictionaries
        for index, row in df.iterrows():
            row_data = {}
            for col in df.columns:
                value = str(row[col]).strip()
                if value and value.lower() != 'nan':
                    row_data[str(col)] = value
            if row_data:
                sheet_data["data"].append(row_data)
        
        # Create content based on output format
        if self._output_format == "json":
            content = json.dumps(sheet_data, indent=2, ensure_ascii=False)
        else:
            content = self._create_sheet_text_content(sheet_data)
        
        # Create domain document
        doc = DomainDocument(
            content=content,
            metadata={
                "source": file_path,
                "type": "xlsx",
                "format": self._output_format,
                "sheet": sheet_name,
                "rows": len(df),
                "columns": len(df.columns)
            }
        )
        
        # Save debug file if enabled
        if self._save_debug_files:
            self._save_debug_file(doc, file_path, f"sheet_{sheet_name}")
        
        return doc
    
    def _create_sheet_text_content(self, sheet_data: Dict[str, Any]) -> str:
        """Create structured text content for a general sheet."""
        lines = []
        lines.append(f"SHEET: {sheet_data['sheet_name']}")
        lines.append(f"ROWS: {sheet_data['rows']}")
        lines.append(f"COLUMNS: {sheet_data['columns']}")
        lines.append(f"COLUMN NAMES: {', '.join(sheet_data['column_names'])}")
        lines.append("")
        lines.append("DATA:")
        lines.append("=" * 50)
        
        for i, row_data in enumerate(sheet_data['data']):
            lines.append(f"Row {i+1}:")
            for key, value in row_data.items():
                lines.append(f"  {key}: {value}")
            lines.append("")
        
        return "\n".join(lines)
    
    def _save_debug_file(self, domain_doc: DomainDocument, file_path: str, doc_id: str) -> None:
        """Save a converted document to debug folder for examination."""
        try:
            # Create filename based on original file and document ID
            original_filename = Path(file_path).stem
            skill_name = domain_doc.metadata.get("skill", "")
            
            if skill_name:
                # For skills, use skill name in filename
                safe_skill_name = "".join(c for c in skill_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
                safe_skill_name = safe_skill_name.replace(' ', '_')
                debug_filename = f"{original_filename}_{safe_skill_name}.{self._output_format}"
            else:
                # For other sheets, use document ID
                debug_filename = f"{original_filename}_{doc_id}.{self._output_format}"
            
            debug_filepath = os.path.join(self._debug_folder, debug_filename)
            
            # Save content to file
            with open(debug_filepath, 'w', encoding='utf-8') as f:
                f.write(f"# Converted from: {file_path}\n")
                f.write(f"# Format: {self._output_format}\n")
                f.write(f"# Metadata: {domain_doc.metadata}\n")
                f.write(f"# Content Length: {len(domain_doc.content)} characters\n")
                f.write("\n" + "="*80 + "\n\n")
                f.write(domain_doc.content)
            
            print(f"ðŸ’¾ Saved structured debug file: {debug_filename}")
            
        except Exception as e:
            print(f"Failed to save debug file: {e}") 